{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83d\ude34 Turbulette, a batteries-included framework to build high performance, async GraphQL APIs \ud83d\ude34 Turbulette packages all you need to build great GraphQL APIs : ASGI framework, GraphQL library, ORM and data validation Features : Split your API in small, independent applications Generate Pydantic models from GraphQL types JWT authentication with refresh and fresh tokens Powerful and extendable policy-based access control (PBAC) Extendable auth user model with role management Async caching (provided by async-caches) Built-in CLI to manage project, apps, and DB migrations Built-in pytest plugin to quickly test your resolvers Settings management at project and app-level (thanks to simple-settings) CSRF middleware 100% test coverage 100% typed, your IDE will thank you ;) Handcrafted with \u2764\ufe0f, from \ud83c\uddeb\ud83c\uddf7 Requirements Python 3.6+ \ud83d\udc4d Turbulette makes use of great tools/frameworks and wouldn't exist without them : Ariadne - Schema-first GraphQL library Starlette - The little ASGI framework that shines GINO - Lightweight, async ORM Pydantic - Powerful data validation with type annotations Alembic - Lightweight database migration tool simple-settings - A generic settings system inspired by Django's one async-caches - Async caching library Click - A \"Command Line Interface Creation Kit\" Installation pip install turbulette You will also need an ASGI server, such as uvicorn : pip install uvicorn \ud83d\ude80 5 min Quick Start Here is a short example that demonstrates a minimal project setup. We will see how to scaffold a simple Turbulette project, create a Turbulette application, and write some GraphQL schema/resolver. It's advisable to start the project in a virtualenv to isolate your dependencies. Here we will be using poetry : poetry init Then, install Turbulette from PyPI : poetry add turbulette 1: Create a project First, create a hello_world/ directory that will contain the whole project. Now, inside this folder, create your Turbulette project using the turb CLI : turb project my-project You should get with something like this : . \u2514\u2500\u2500 \ud83d\udcc1 my-project \u251c\u2500\u2500 \ud83d\udcc1 alembic \u2502 \u251c\u2500\u2500 \ud83d\udcc4 env.py \u2502 \u2514\u2500\u2500 \ud83d\udcc4 script.py.mako \u251c\u2500\u2500 \ud83d\udcc4 .env \u251c\u2500\u2500 \ud83d\udcc4 alembic.ini \u251c\u2500\u2500 \ud83d\udcc4 app.py \u2514\u2500\u2500 \ud83d\udcc4 settings.py Let's break down the structure : \ud83d\udcc1 my-project : Here is the so-called Turbulette project folder, it will contain applications and project-level configuration files \ud83d\udcc1 alembic : Contains the Alembic scripts used when generating/applying DB migrations \ud83d\udcc4 env.py \ud83d\udcc4 script.py.mako \ud83d\udcc4 .env : The actual project settings live here \ud83d\udcc4 app.py : Your API entrypoint, it contains the ASGI app \ud83d\udcc4 settings.py : Will load settings from .env file Question Why have both .env and settings.py ? You don't have to . You can also put all your settings in settings.py . But Turbulette encourage you to follow the twelve-factor methodology , that recommend to separate settings from code because config varies substantially across deploys, code does not . This way, you can untrack .env from version control and only keep tracking settings.py , which will load settings from .env using Starlette's Config object. 2: Create the first app Now it's time to create a Turbulette application! Run this command under the project directory ( my-project ) : turb app --name hello-world Info You need to run turb app under the project dir because the CLI needs to access the almebic.ini file to create the initial database migration. You should see your new app under the project folder : . \u2514\u2500\u2500 \ud83d\udcc1 my-project ... | \u2514\u2500\u2500 \ud83d\udcc1 hello-world \u251c\u2500\u2500 \ud83d\udcc1 graphql \u251c\u2500\u2500 \ud83d\udcc1 migrations \u2502 \u2514\u2500\u2500 \ud83d\udcc4 20200926_1508_auto_ef7704f9741f_initial.py \u251c\u2500\u2500 \ud83d\udcc1 resolvers \u2514\u2500\u2500 \ud83d\udcc4 models.py Details : \ud83d\udcc1 graphql : All the GraphQL schema will live here \ud83d\udcc1 migrations : Will contain database migrations generated by Alembic \ud83d\udcc1 resolvers : Python package where you will write resolvers binded to the schema \ud83d\udcc4 models.py : Will hold GINO models for this app 3: GraphQL schema Now that we have our project scaffold, we can start writing actual schema/code. Create a schema.gql file in the \ud83d\udcc1 graphql folder and add this base schema : extend type Query { user: [User] } type User { id: ID! username: String! gender: String! isStaff: Boolean! } Info Note that we extend the type Query because Turbulette already defines it. The same goes for Mutation type 4: Add a resolver The last missing piece is the resolver for our user query, to make the API returning something when querying for it. As you may have guessed, we will create a new Python module in our \ud83d\udcc1 resolvers package. Let's call it user.py : from turbulette import query @query . field ( \"user\" ) async def user ( obj , info , ** kwargs ): return [ { \"id\" : 1 , \"username\" : \"Gustave Eiffel\" , \"gender\" : \"male\" , \"is_staff\" : False }, { \"id\" : 2 , \"username\" : \"Marie Curie\" , \"gender\" : \"female\" , \"is_staff\" : True }, ] 5: Run it Our user query is now binded to the schema, so let's test it. Start the server : poetry run uvicorn app:app --port 8000 Now, go to http://localhost:8000/graphql , you will see the GraphQL Playground IDE. Finally, run the user query, for example : query { user { id username gender isStaff } } Should give you the following expected result : { \"data\" : { \"user\" : [ { \"id\" : \"1\" , \"username\" : \"Gustave Eiffel\" , \"gender\" : \"male\" , \"isStaff\" : false }, { \"id\" : \"2\" , \"username\" : \"Marie Curie\" , \"gender\" : \"female\" , \"isStaff\" : true } ] } } Good job! That was a straightforward example, showing off the bare minimum needed to set up a Turbulette API. To get the most of it, follow the User Guide.","title":"Turbulette"},{"location":"#requirements","text":"Python 3.6+ \ud83d\udc4d Turbulette makes use of great tools/frameworks and wouldn't exist without them : Ariadne - Schema-first GraphQL library Starlette - The little ASGI framework that shines GINO - Lightweight, async ORM Pydantic - Powerful data validation with type annotations Alembic - Lightweight database migration tool simple-settings - A generic settings system inspired by Django's one async-caches - Async caching library Click - A \"Command Line Interface Creation Kit\"","title":"Requirements"},{"location":"#installation","text":"pip install turbulette You will also need an ASGI server, such as uvicorn : pip install uvicorn","title":"Installation"},{"location":"#5-min-quick-start","text":"Here is a short example that demonstrates a minimal project setup. We will see how to scaffold a simple Turbulette project, create a Turbulette application, and write some GraphQL schema/resolver. It's advisable to start the project in a virtualenv to isolate your dependencies. Here we will be using poetry : poetry init Then, install Turbulette from PyPI : poetry add turbulette","title":"\ud83d\ude80  5 min Quick Start"},{"location":"#1-create-a-project","text":"First, create a hello_world/ directory that will contain the whole project. Now, inside this folder, create your Turbulette project using the turb CLI : turb project my-project You should get with something like this : . \u2514\u2500\u2500 \ud83d\udcc1 my-project \u251c\u2500\u2500 \ud83d\udcc1 alembic \u2502 \u251c\u2500\u2500 \ud83d\udcc4 env.py \u2502 \u2514\u2500\u2500 \ud83d\udcc4 script.py.mako \u251c\u2500\u2500 \ud83d\udcc4 .env \u251c\u2500\u2500 \ud83d\udcc4 alembic.ini \u251c\u2500\u2500 \ud83d\udcc4 app.py \u2514\u2500\u2500 \ud83d\udcc4 settings.py Let's break down the structure : \ud83d\udcc1 my-project : Here is the so-called Turbulette project folder, it will contain applications and project-level configuration files \ud83d\udcc1 alembic : Contains the Alembic scripts used when generating/applying DB migrations \ud83d\udcc4 env.py \ud83d\udcc4 script.py.mako \ud83d\udcc4 .env : The actual project settings live here \ud83d\udcc4 app.py : Your API entrypoint, it contains the ASGI app \ud83d\udcc4 settings.py : Will load settings from .env file Question Why have both .env and settings.py ? You don't have to . You can also put all your settings in settings.py . But Turbulette encourage you to follow the twelve-factor methodology , that recommend to separate settings from code because config varies substantially across deploys, code does not . This way, you can untrack .env from version control and only keep tracking settings.py , which will load settings from .env using Starlette's Config object.","title":"1: Create a project"},{"location":"#2-create-the-first-app","text":"Now it's time to create a Turbulette application! Run this command under the project directory ( my-project ) : turb app --name hello-world Info You need to run turb app under the project dir because the CLI needs to access the almebic.ini file to create the initial database migration. You should see your new app under the project folder : . \u2514\u2500\u2500 \ud83d\udcc1 my-project ... | \u2514\u2500\u2500 \ud83d\udcc1 hello-world \u251c\u2500\u2500 \ud83d\udcc1 graphql \u251c\u2500\u2500 \ud83d\udcc1 migrations \u2502 \u2514\u2500\u2500 \ud83d\udcc4 20200926_1508_auto_ef7704f9741f_initial.py \u251c\u2500\u2500 \ud83d\udcc1 resolvers \u2514\u2500\u2500 \ud83d\udcc4 models.py Details : \ud83d\udcc1 graphql : All the GraphQL schema will live here \ud83d\udcc1 migrations : Will contain database migrations generated by Alembic \ud83d\udcc1 resolvers : Python package where you will write resolvers binded to the schema \ud83d\udcc4 models.py : Will hold GINO models for this app","title":"2: Create the first app"},{"location":"#3-graphql-schema","text":"Now that we have our project scaffold, we can start writing actual schema/code. Create a schema.gql file in the \ud83d\udcc1 graphql folder and add this base schema : extend type Query { user: [User] } type User { id: ID! username: String! gender: String! isStaff: Boolean! } Info Note that we extend the type Query because Turbulette already defines it. The same goes for Mutation type","title":"3: GraphQL schema"},{"location":"#4-add-a-resolver","text":"The last missing piece is the resolver for our user query, to make the API returning something when querying for it. As you may have guessed, we will create a new Python module in our \ud83d\udcc1 resolvers package. Let's call it user.py : from turbulette import query @query . field ( \"user\" ) async def user ( obj , info , ** kwargs ): return [ { \"id\" : 1 , \"username\" : \"Gustave Eiffel\" , \"gender\" : \"male\" , \"is_staff\" : False }, { \"id\" : 2 , \"username\" : \"Marie Curie\" , \"gender\" : \"female\" , \"is_staff\" : True }, ]","title":"4: Add a resolver"},{"location":"#5-run-it","text":"Our user query is now binded to the schema, so let's test it. Start the server : poetry run uvicorn app:app --port 8000 Now, go to http://localhost:8000/graphql , you will see the GraphQL Playground IDE. Finally, run the user query, for example : query { user { id username gender isStaff } } Should give you the following expected result : { \"data\" : { \"user\" : [ { \"id\" : \"1\" , \"username\" : \"Gustave Eiffel\" , \"gender\" : \"male\" , \"isStaff\" : false }, { \"id\" : \"2\" , \"username\" : \"Marie Curie\" , \"gender\" : \"female\" , \"isStaff\" : true } ] } } Good job! That was a straightforward example, showing off the bare minimum needed to set up a Turbulette API. To get the most of it, follow the User Guide.","title":"5: Run it"},{"location":"changelogs/","text":"0.2.0 Features Generate Pydantic models from schema Policy based access control (PBAC) Add fresh token Add Turbulette CLI turb Add CRUD role methods on auth user model Add async-caches Add csrf middleware Add ariadne extensions through settings Add set_password() to AbtractUser Allow to start a project with no database connection Fixes Fix error when no routes was defined More consistent error codes Add mypy and black checks Docs Add quickstart documentation CI Move from Travis CI to Github Action Add pre-commit hooks Add mypy and black formatting checks in test workflow","title":"Release Notes"},{"location":"changelogs/#020","text":"","title":"0.2.0"},{"location":"changelogs/#features","text":"Generate Pydantic models from schema Policy based access control (PBAC) Add fresh token Add Turbulette CLI turb Add CRUD role methods on auth user model Add async-caches Add csrf middleware Add ariadne extensions through settings Add set_password() to AbtractUser Allow to start a project with no database connection","title":"Features"},{"location":"changelogs/#fixes","text":"Fix error when no routes was defined More consistent error codes Add mypy and black checks","title":"Fixes"},{"location":"changelogs/#docs","text":"Add quickstart documentation","title":"Docs"},{"location":"changelogs/#ci","text":"Move from Travis CI to Github Action Add pre-commit hooks Add mypy and black formatting checks in test workflow","title":"CI"},{"location":"faq/","text":"Isn't the project structure similar to Django's one? If you already used Django before, you probably noticed similarities with the project structure, as Turbulette is strongly inspired by the modular design of Django apps and the default project skeleton. The idea is to give the developers a default way of doing things while keeping the flexibility to write more complex projects. For instance, if your resolvers have to be available under the \ud83d\udcc1 resolvers folder, It's just a Python package at the end. You are free to move them elsewhere and to import them all inside \ud83d\udcc1 resolvers .","title":"FAQ"},{"location":"faq/#isnt-the-project-structure-similar-to-djangos-one","text":"If you already used Django before, you probably noticed similarities with the project structure, as Turbulette is strongly inspired by the modular design of Django apps and the default project skeleton. The idea is to give the developers a default way of doing things while keeping the flexibility to write more complex projects. For instance, if your resolvers have to be available under the \ud83d\udcc1 resolvers folder, It's just a Python package at the end. You are free to move them elsewhere and to import them all inside \ud83d\udcc1 resolvers .","title":"Isn't the project structure similar to Django's one?"},{"location":"user-guide/","text":"WIP","title":"User Guide"}]}